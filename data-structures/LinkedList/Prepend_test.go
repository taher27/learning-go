// ********RoostGPT********
/*
Test generated by RoostGPT for test testingGoCoverage using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=Prepend_d8f663423f
ROOST_METHOD_SIG_HASH=Prepend_747252e40f

================================================================================
Scenario 1: Prepending to an Empty LinkedList

Details:
  Description: This test is meant to check the behavior of the Prepend function when the LinkedList is empty. It specifically tests if a new node is correctly added to the head of the LinkedList.
Execution:
  Arrange: Create an empty LinkedList.
  Act: Invoke the Prepend function with an integer value.
  Assert: Check if the head of the LinkedList is not nil and its value matches the value passed to the Prepend function.
Validation:
  The choice of assertion is based on the expected behavior of the function - it should create a new node with the provided value and assign it to the head of the LinkedList. This test is important as it validates the basic functionality of the Prepend function.

Scenario 2: Prepending to a Non-Empty LinkedList

Details:
  Description: This test is meant to check the behavior of the Prepend function when the LinkedList already has one or more nodes. It specifically tests if a new node is correctly added to the head of the LinkedList and if the old head becomes the next node of the new head.
Execution:
  Arrange: Create a LinkedList and add a node to it.
  Act: Invoke the Prepend function with a new integer value.
  Assert: Check if the head of the LinkedList is not nil and its value matches the new value. Also, check if the next node of the head matches the old head.
Validation:
  The assertion is based on the expected behavior of the function - it should create a new node with the provided value, assign it to the head of the LinkedList, and make the old head the next node of the new head. This test is important as it verifies the correct functioning of the Prepend function when the LinkedList is not empty.

Scenario 3: Prepending Multiple Values

Details:
  Description: This test is meant to check the behavior of the Prepend function when it is called multiple times. It specifically tests if each new node is correctly added to the head of the LinkedList and if the LinkedList maintains the correct order of nodes.
Execution:
  Arrange: Create an empty LinkedList.
  Act: Invoke the Prepend function multiple times with different integer values.
  Assert: Check if the head of the LinkedList is not nil and its value matches the value of the last Prepend call. Also, check if the LinkedList contains all the values in the correct order.
Validation:
  The assertion is based on the expected behavior of the function - each call to Prepend should add a new node to the head of the LinkedList and the LinkedList should maintain the correct order of nodes. This test is important as it validates the function's ability to correctly handle multiple calls.
*/

// ********RoostGPT********
package LinkedList

import (
	"testing"
)

func TestPrepend(t *testing.T) {
	tests := []struct {
		name   string
		values []int
	}{
		{
			name:   "Prepending to an Empty LinkedList",
			values: []int{1},
		},
		{
			name:   "Prepending to a Non-Empty LinkedList",
			values: []int{1, 2},
		},
		{
			name:   "Prepending Multiple Values",
			values: []int{1, 2, 3, 4, 5},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ll := &LinkedList{}
			for _, val := range tt.values {
				ll.Prepend(val)
			}

			// assert head of the list
			if ll.head == nil {
				t.Fatalf("failed %s: head of the list is nil", tt.name)
			}

			if ll.head.val != tt.values[len(tt.values)-1] {
				t.Fatalf("failed %s: head of the list is not the last prepended value", tt.name)
			}

			// assert all prepended values exist in the list in the reverse order
			current := ll.head
			for i := len(tt.values) - 1; i >= 0; i-- {
				if current == nil {
					t.Fatalf("failed %s: list is shorter than the number of prepended values", tt.name)
				}

				if current.val != tt.values[i] {
					t.Fatalf("failed %s: value at position %d is not correct", tt.name, len(tt.values)-1-i)
				}

				current = current.next
			}

			t.Logf("passed %s", tt.name)
		})
	}
}
