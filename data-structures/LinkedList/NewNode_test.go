// ********RoostGPT********
/*
Test generated by RoostGPT for test testingGoCoverage using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=NewNode_382369d7a5
ROOST_METHOD_SIG_HASH=NewNode_60e8401887

================================VULNERABILITIES================================
Vulnerability: None
Issue: No security vulnerability identified in the code snippet.
Solution: N/A

================================================================================
Scenario 1: Test for Valid Integer Input Val

Details:
Description: This test is meant to validate that the NewNode function works as expected when a valid integer is passed as input val. The target scenario is to make sure that the function properly initializes a new node with the given integer set as val, next and prev pointers set as nil.

Execution:
Arrange: No data setup is required as we will directly pass integer val to function.
Act: Invoke the NewNode function and pass valid integer as parameter.
Assert: Use the Go testing facilities to verify that the returned node's val field is the same as the passed integer and next, prev pointers are nil.

Validation:
The expected result is based on the requirement that the NewNode function should create a new node with val set to the passed argument value and next, prev pointers set to nil. We need to ensure that next and prev pointers are initialised properly as future operations on them should not result in errors. This test ensures that basic functionality of node creation using integer input works as expected.

Scenario 2: Test for Zero Integer Input Val

Details:
Description: This test seeks to validate that the function properly initializes a new node with val set to zero, next and prev pointers set as nil.
Execution:
Arrange: No data setup is required as we will directly pass integer val to function.
Act: Invoke the NewNode function and pass 0 as parameter.
Assert: Use the Go testing facilities to check that the returned node's val field is zero and next, prev pointers are nil.

Validation:
The choice of assertion is grounded on the expectation that the node should be initialised properly even when 0 is passed as input. It ensures that function works correctly for edge case of passing zero as input.

Scenario 3: Test for Negative Integer Input Val

Details:
Description: This test aims to validate that the function behaves as expected even when a negative integer value is passed to it.
Execution:
Arrange: No data setup is required as we will directly pass negative integer val to function.
Act: Invoke the NewNode function and pass a negative integer as parameter.
Assert: Use the Go testing facilities to validate that the returned node's val field is the same as the passed negative integer and next, prev pointers are set to nil.

Validation:
The test's assertion confirms that function handles negative values correctly, ensuring that unlike languages that do not support negative array indices or do not permit negative integers in this context, GoLang handles this correctly within this function. The test is critical for validating the robustness of the function in handling edge cases.
*/

// ********RoostGPT********
package LinkedList

import (
	"testing"
)

func TestNewNode(t *testing.T) {
	// Test Scenarios
	testScenarios := []struct {
		desc   string
		input  int
		expect func(*node) bool
	}{
		{
			desc:  "Test for Valid Integer Input Val",
			input: 10,
			expect: func(n *node) bool {
				return n.val == 10 && n.next == nil && n.prev == nil
			},
		},
		{
			desc:  "Test for Zero Integer Input Val",
			input: 0,
			expect: func(n *node) bool {
				return n.val == 0 && n.next == nil && n.prev == nil
			},
		},
		{
			desc:  "Test for Negative Integer Input Val",
			input: -5,
			expect: func(n *node) bool {
				return n.val == -5 && n.next == nil && n.prev == nil
			},
		},
	}

	// Running test for each scenario
	for _, scenario := range testScenarios {
		t.Run(scenario.desc, func(t *testing.T) {
			result := NewNode(scenario.input)

			if !scenario.expect(result) {
				t.Errorf("failed %s: expected values not matching for input val:%d", scenario.desc, scenario.input)
			} else {
				t.Logf("success %s: expected and returned values match for input val:%d", scenario.desc, scenario.input)
			}
		})
	}
}

type node struct {
	val	int
	next	*node
	prev	*node
}

// NewNode creates new node in double linked list with provided integer value
func NewNode(val int) *node {
	n := &node{}
	n.val = val
	n.next = nil
	n.prev = nil
	return n
}
