// ********RoostGPT********
/*
Test generated by RoostGPT for test testingGoCoverage using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=RemoveAtBeg_2301eda597
ROOST_METHOD_SIG_HASH=RemoveAtBeg_e45f33f4b9

================================VULNERABILITIES================================
Vulnerability: Usage of magic number for error handling
Issue: Returning a magic number (-1) to indicate an error condition can lead to confusion and is not idiomatic in Go.
Solution: Instead of returning -1, return a second, optional error value. This is more idiomatic in Go and makes error handling more explicit and robust.

================================================================================
Scenario 1: Test with an empty LinkedList

Details:
  Description: This test is designed to verify the function's behavior when it is called on an empty LinkedList. The expected behavior is that the function should return -1 because there is no node to remove.

Execution:
  Arrange: Create an instance of LinkedList with no nodes.
  Act: Call the RemoveAtBeg function on the empty LinkedList.
  Assert: Assert that the returned value is -1.

Validation:
  The assertion is based on the function's design to return -1 when there are no nodes to remove. This test is important to ensure the function handles edge cases correctly and does not cause any unexpected behavior when the LinkedList is empty.

Scenario 2: Test with a LinkedList containing one node

Details:
  Description: This test is meant to check the function's behavior when it is called on a LinkedList containing one node. The function should return the value of the node and the LinkedList should become empty.

Execution:
  Arrange: Create an instance of LinkedList with one node.
  Act: Call the RemoveAtBeg function on the LinkedList.
  Assert: Assert that the returned value is the same as the value of the node and the LinkedList is now empty.

Validation:
  The assertion is based on the function's design to return the value of the removed node. This test is important to ensure the function works correctly with a LinkedList of size one and leaves the LinkedList in the correct state.

Scenario 3: Test with a LinkedList containing multiple nodes

Details:
  Description: This test is designed to check the function's behavior when it is called on a LinkedList containing multiple nodes. The function should return the value of the first node and the LinkedList should be updated accordingly.

Execution:
  Arrange: Create an instance of LinkedList with multiple nodes.
  Act: Call the RemoveAtBeg function on the LinkedList.
  Assert: Assert that the returned value is the same as the value of the first node and the first node of the LinkedList is now the second node.

Validation:
  The assertion is based on the function's design to return the value of the first node and update the LinkedList. This test is important to ensure the function works correctly with a LinkedList of size greater than one and leaves the LinkedList in the correct state.
*/

// ********RoostGPT********
package LinkedList

import (
	"testing"
)

type node struct {
	val  int
	next *node
	prev *node
}

type LinkedList struct{ head *node }

func (ll *LinkedList) RemoveAtBeg() int {
	if ll.head == nil {
		return -1
	}
	cur := ll.head
	ll.head = cur.next
	if ll.head != nil {
		ll.head.prev = nil
	}
	return cur.val
}

func TestRemoveAtBeg(t *testing.T) {
	// Test Scenario 1: Test with an empty LinkedList
	{
		ll := &LinkedList{}
		result := ll.RemoveAtBeg()
		if result != -1 {
			t.Fatalf("Expected -1, but got %d", result)
		}
		t.Log("Passed Test Scenario 1: Test with an empty LinkedList")
	}

	// Test Scenario 2: Test with a LinkedList containing one node
	{
		n := &node{val: 10}
		ll := &LinkedList{head: n}
		result := ll.RemoveAtBeg()
		if result != 10 || ll.head != nil {
			t.Fatalf("Expected 10 and nil, but got %d and %v", result, ll.head)
		}
		t.Log("Passed Test Scenario 2: Test with a LinkedList containing one node")
	}

	// Test Scenario 3: Test with a LinkedList containing multiple nodes
	{
		n1 := &node{val: 10}
		n2 := &node{val: 20, prev: n1}
		n1.next = n2
		ll := &LinkedList{head: n1}
		result := ll.RemoveAtBeg()
		if result != 10 || ll.head != n2 {
			t.Fatalf("Expected 10 and second node, but got %d and %v", result, ll.head)
		}
		t.Log("Passed Test Scenario 3: Test with a LinkedList containing multiple nodes")
	}
}
