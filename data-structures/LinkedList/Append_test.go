// ********RoostGPT********
/*
Test generated by RoostGPT for test testingGoCoverage using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=Append_573245c515
ROOST_METHOD_SIG_HASH=Append_3c0174cec2

================================VULNERABILITIES================================
Vulnerability: None
Issue: No specific security issues found in the provided Golang code snippet.
Solution: No action needed.

================================================================================
Scenario 1: Append to an Empty LinkedList

Details:
    Description: This test is meant to check if the Append function correctly adds an element to an empty LinkedList. The goal is to ensure that the function correctly sets the head of the LinkedList to the new node when the LinkedList is empty.
Execution:
    Arrange: Create an empty LinkedList.
    Act: Invoke the Append function with any integer.
    Assert: Use Go's reflect.DeepEqual to verify that the head of the LinkedList is the new node.
Validation:
    The assertion choice checks if the head of the LinkedList is correctly set to the new node when the LinkedList is empty. This test is crucial as it verifies the basic functionality of the Append function.

Scenario 2: Append to a Non-Empty LinkedList

Details:
    Description: This test is meant to check if the Append function correctly adds an element to a non-empty LinkedList. The goal is to ensure that the function correctly adds the new node at the end of the LinkedList and sets the 'prev' field of the new node to the last node in the LinkedList.
Execution:
    Arrange: Create a LinkedList with one or more nodes.
    Act: Invoke the Append function with any integer.
    Assert: Use Go's reflect.DeepEqual to verify that the new node is correctly added at the end of the LinkedList and its 'prev' field is set to the last node.
Validation:
    The assertion choice checks if the new node is correctly added at the end of the LinkedList and its 'prev' field is correctly set. This test is crucial as it verifies that the Append function correctly handles the case when the LinkedList is not empty.

Scenario 3: Append Multiple Nodes

Details:
    Description: This test is meant to check if the Append function correctly adds multiple nodes to the LinkedList. The goal is to ensure that the function maintains the order of the nodes and correctly sets the 'prev' field for each new node.
Execution:
    Arrange: Create an empty LinkedList.
    Act: Invoke the Append function multiple times with different integers.
    Assert: Use Go's reflect.DeepEqual to verify that the nodes are added in the correct order and the 'prev' field for each node is correctly set.
Validation:
    The assertion choice checks if the nodes are added in the correct order and the 'prev' field for each node is correctly set. This test is crucial as it verifies that the Append function correctly handles multiple invocations.
*/

// ********RoostGPT********
package LinkedList

import (
	"reflect"
	"testing"
)

// Node struct for testing
type node struct {
	val  int
	prev *node
	next *node
}

// TestAppend function for testing Append function
func TestAppend(t *testing.T) {
	// Test cases
	tests := []struct {
		name     string
		input    []int
		expected *node
	}{
		{
			name:     "Append to an Empty LinkedList",
			input:    []int{5},
			expected: NewNode(5),
		},
		{
			name: "Append to a Non-Empty LinkedList",
			input: []int{7, 8},
			expected: func() *node {
				node1 := NewNode(7)
				node2 := NewNode(8)
				node1.next = node2
				node2.prev = node1
				return node1
			}(),
		},
		{
			name: "Append Multiple Nodes",
			input: []int{1, 2, 3},
			expected: func() *node {
				node1 := NewNode(1)
				node2 := NewNode(2)
				node3 := NewNode(3)
				node1.next = node2
				node2.prev = node1
				node2.next = node3
				node3.prev = node2
				return node1
			}(),
		},
	}

	// Running tests
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			ll := &LinkedList{}
			for _, val := range test.input {
				ll.Append(val)
			}
			if !reflect.DeepEqual(ll.head, test.expected) {
				t.Errorf("Expected %+v, got %+v", test.expected, ll.head)
			}
		})
	}
}
